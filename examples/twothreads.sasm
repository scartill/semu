// ROM image assembly file

ldr &start a
jmp a

DW runpt
DW mainsp
DW mainnext
DW secsp
DW secnext

// Start - setup user interrupt handler
start:
ldr &loopback a
ldc 0 b     // int 0 handler address
mrm a b     // Handler = loopback

// Setup timer
ldr &timer a
ldc 4 b     // int 1 handler address
mrm a b     // Handler = timer
ldc 1 a     // enable == 1
ldc 1 b     // serial on line 1
out a b     // Enable timer

// Setup main TCB
ldc 2048 a
lsp a           // main SP = 2048
ldr &main h
psh h           // Thread start = main
ldc 65 h
psh h               // a
psh h               // b
psh h               // c
psh h               // d
psh h               // e
psh h               // f
psh h               // g
psh h               // h
ssp a               // Updated SP
ldr &mainsp b
mrm a b             // mainsp = 2048 + bootstrap
ldr &secsp c
ldr &mainnext d
mrm c d             // mainnext = &secsp

// Setup second TCB
ldc 3092 e  
lsp e
ldr &second h
psh h               // Thread start = second
ldc 66 h
psh h               // a
psh h               // b
psh h               // c
psh h               // d
psh h               // e
psh h               // f
psh h               // g
psh h               // h
ssp e
ldr &secsp f
mrm e f             // secsp = 3092 + bootstrap
ldr &secnext g
mrm b g             // secnext = &mainsp

// Set running TCP
ldr &runpt h
mrm b h             // runpt = &mainsp

// Running main thread
lsp a
irx

// Main thread
main:
CALL mainloop

// Secondary thread
second:
CALL mainloop

// Generic loop
mainloop:
 // 'A' or 'B' symbol
int a
nop
ldr &mainloop c
jmp c

// User interrupt handler - send 'word' to serial
loopback:
ldc 2 b
out a b
irx

// Timer tick handler - schedule the next thread
timer:
ldr &runpt a
mmr a b         // b = *runpt

// Save stack pointer
ssp c
mrm c b         // runpt->sp = sp

ldc 4 d
add b d b
mmr b e         // e = runpt->next

// Update running TCB
mrm e a

// Fetch new stack pointer
mmr e g
lsp g

// Resume that thread
irx
