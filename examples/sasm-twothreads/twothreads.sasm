// ROM image assembly file

ldr &start a
jmp a

// Global vars
DW runpt
DW mainsp
DW mainnext
DW secsp
DW secnext

// Init stack for a new thread
// a = <stack top>
// b = <func>
// c = <init value>
// ret: a <- new thread stack head
FUNC initstack
    ssp d               // Save start-up stack
    lsp a               // Main SP = <stack top>
    push b               // Thread start = <func>
    push c               // a := <init value>
    push c               // b := <init value>
    push c               // c := <init value>
    push c               // d := <init value>
    push c               // e := <init value>
    push c               // f := <init value>
    push c               // g := <init value>
    push c               // h := <init value>
    ssp a               // Updated SP
    lsp d               // Restore start-up stack
    ret

// Main thread
// input: a - 'A' or 'B' symbol
FUNC main
    int a
    nop
    ldr &main c
    jmp c

// Secondary thread
FUNC second
    int a
    push a
    CALL ASuspend
    pop a
    nop
    ldr &second c
    jmp c

// API Suspend
FUNC ASuspend
    ldc 0 a
    int a
    ret

// User interrupt handler - send 'word' to serial
// input: a - symbol to 'out'. 0 for force timer to suspend
FUNC KLoopback
  suspend:
    ldr &serial b
    jgt a b
    ldr &KScheduler b       // NB: no 'cll' instruction
    jmp b                   // - saving the stack intact
    
  serial:
    ldc 2 b
    out a b
    irx

// Timer tick handler - schedule the next thread
FUNC KScheduler
    ldr &runpt a
    mmr a b         // b = *runpt

    // Save stack pointer
    ssp c
    mrm c b         // runpt->sp = sp

    ldc 4 d
    add b d b
    mmr b e         // e = runpt->next

    // Update running TCB
    mrm e a

    // Fetch new stack pointer
    mmr e g
    lsp g

    // Resume that thread
    irx

// Start - setup user interrupt handler
start:
bpt 0
// Start-up stack
ldc 2000 a
lsp a

// Loopback handler
ldr &KLoopback a
ldc 0 b     // int 0 handler address
mrm a b     // Handler = loopback

// Setup timer
ldr &KScheduler a
ldc 4 b     // int 1 handler address
mrm a b     // Handler = scheduler
ldc 1 a     // enable == 1
ldc 1 b     // serial on line 1
out a b     // Enable timer

// Setup main thread stack
ldc 2048 a
ldr &main b
ldc 65 c
CALL initstack      // a <- new SP

// Fill main TCP
ldr &mainsp b
mrm a b             // mainsp = 2048 + bootstrap
ldr &secsp c
ldr &mainnext d
mrm c d             // mainnext = &secsp

// Setup second thread stack
ldc 3092 a
ldr &second b
ldc 66 c
CALL initstack      // a <- new SP

// Fill second TCP
ldr &secsp b
mrm a b             // secsp = 3092 + bootstrap
ldr &secnext g
ldr &mainsp b
mrm b g             // secnext = &mainsp

// Set running TCP
ldr &runpt h
mrm b h             // runpt = &mainsp

// Running main thread
mmr b a
lsp a
irx

