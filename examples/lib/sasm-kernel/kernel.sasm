/// Kernel functions

STRUCT TCB
    DW sp
    DW next
    DW prev
END

// Global vars
DW runpt
DS TCB idletcb

// Create idle thread
FUNC CreateIdle
    ldc 2048 a
    ldr &TIdle b
    CALL InitStack      // a <- SP
    
    ldr &idletcb b
    PTR b sp#TCB h      // idletcb.sp = a
    mrm a h
    PTR b next#TCB h    // idletcb.next = &idletcb
    mrm b h
    PTR b prev#TCB h    // idletcb.prev = &idletcb
    mrm b h
    ldr &runpt h        // runpt = &idletcb
    mrm b h
    ret                 // return a

// System idle thread
FUNC TIdle
    nop
    ldc 73 a            // a <- 'I'
    CALL api::Print    
    CALL api::Suspend
    ldr &TIdle c
    jmp c

FUNC Startup    
    CALL SetupHandlers
    CALL CreateIdle
    
    // Return idle thread stack pointer    
    ldr &runpt a
    RPTR a sp#TCB b
    mmr b a             // return runpt->sp
    ret

FUNC CreateThread // stack_top, func
    CALL InitStack             // a <- new_stack
      
    PTR d sp#TCB h
    mrm a h                     // tcb.sp = stack_top
    PTR d next#TCB h
    mrm e h                     // tcp.next = next_tcb
    ret

// Init stack for a new thread
FUNC InitStack // stack_top, func -> new_stack
    mrm b a             // Thread start = <func>
    ldc 36 c
    add a c a
    ret
    
// Setup interrupt handlers
FUNC SetupHandlers
    // Loopback handler
    ldr &HLoopback a
    ldc 0 b     // int 0 handler address
    mrm a b     // Handler = loopback

    // Setup timer
    ldr &HScheduler a
    ldc 4 b     // int 1 handler address
    mrm a b     // Handler = scheduler
    ldc 1 a     // enable == 1
    ldc 1 b     // serial on line 1
    out a b     // Enable timer
    
    ret

// User interrupt handler - send 'word' to serial
// input: a - symbol to 'out'. 0 for force timer to suspend
FUNC HLoopback
  suspend:
    ldr &serial b
    jgt a b
    ldr &HScheduler b       // NB: no 'cll' instruction
    jmp b                   // - saving the stack intact
    
  serial:
    ldc 2 b
    out a b
    irx

// Timer tick handler - schedule the next thread
FUNC HScheduler
    ldr &runpt a
    
    // Save stack pointer
    RPTR a sp#TCB b
    ssp c
    mrm c b         // runpt->sp = sp

    RPTR a next#TCB b
    mmr b e         // e = runpt->next

    // Update running TCB
    mrm e a

    // Fetch new stack pointer    
    RPTR a sp#TCB b
    mmr b c
    lsp c

    // Resume that thread
    irx    


