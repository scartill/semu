/// Kernel functions

STRUCT TCP
    DW sp
    DW next
END

// Global vars
DW runpt
DS TCP main
DS TCP second

DS TCP threads*10

FUNC KStartup
    // Setup interrupt handlers
    CALL KSetupHandlers

//    ldr &kernel::threads a
//    ldc 0 b    
//    ITEM TCP a b
    
    // Setup main thread stack
    ldc 2048 a
    ldr &twothreads::main b
    ldc 65 c
    ldr &main d
    ldr &second e
    CALL KInitThread

    // Setup second thread stack
    ldc 3092 a
    ldr &twothreads::second b
    ldc 66 c    
    ldr &second d
    ldr &main e
    CALL KInitThread

    // Set running TCP
    ldr &runpt a
    ldr &main b
    mrm b a                     // runpt = &main

    // Return main thread stack pointer    
    PTR b sp#TCP b
    mmr b a                     // a <- main.sp
    ret

FUNC KInitThread // stack_top, func, init_value, tcb, next_tcb
    push b
    push c
    push d
    push e
    CALL KInitStack
    pop e
    pop d
    pop c
    pop b
      
    PTR d sp#TCP h
    mrm a h                     // tcb.sp = stack_top
    PTR d next#TCP h
    mrm e h                     // tcp.next = next_tcb
    ret

// Init stack for a new thread
FUNC KInitStack // stack_top, func, init_value -> new_stack
    ssp d               // Save start-up stack
    lsp a               // Main SP = <stack top>
    push b              // Thread start = <func>
    push c              // a := <init value>
    push c              // b := <init value>
    push c              // c := <init value>
    push c              // d := <init value>
    push c              // e := <init value>
    push c              // f := <init value>
    push c              // g := <init value>
    push c              // h := <init value>
    ssp a               // Updated SP
    lsp d               // Restore start-up stack
    ret
    
// Setup interrupt handlers
FUNC KSetupHandlers
    // Loopback handler
    ldr &HLoopback a
    ldc 0 b     // int 0 handler address
    mrm a b     // Handler = loopback

    // Setup timer
    ldr &HScheduler a
    ldc 4 b     // int 1 handler address
    mrm a b     // Handler = scheduler
    ldc 1 a     // enable == 1
    ldc 1 b     // serial on line 1
    out a b     // Enable timer
    
    ret

// User interrupt handler - send 'word' to serial
// input: a - symbol to 'out'. 0 for force timer to suspend
FUNC HLoopback
  suspend:
    ldr &serial b
    jgt a b
    ldr &HScheduler b       // NB: no 'cll' instruction
    jmp b                   // - saving the stack intact
    
  serial:
    ldc 2 b
    out a b
    irx

// Timer tick handler - schedule the next thread
FUNC HScheduler
    ldr &runpt a
    
    // Save stack pointer
    RPTR a sp#TCP b
    ssp c
    mrm c b         // runpt->sp = sp

    RPTR a next#TCP b
    mmr b e         // e = runpt->next

    // Update running TCB
    mrm e a

    // Fetch new stack pointer    
    RPTR a sp#TCP b
    mmr b c
    lsp c

    // Resume that thread
    irx    


