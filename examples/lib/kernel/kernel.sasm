/// Kernel functions

STRUCT TCB
    DW sp
    DW next
    DW prev
END

// Running thread pointer
DW runpt

// Create idle thread
DW idlestack*100
DS TCB idletcb

// Create a thread that never stops
FUNC CreateSysThread BEGIN
    ldr &idlestack a
    ldr &TSysThread b
    ldc 0 c
    CALL InitStack      // a <- SP
    
    ldr &idletcb b
    PTR b sp#TCB h      // idletcb.sp = a
    mrm a h
    PTR b next#TCB h    // idletcb.next = &idletcb
    mrm b h
    PTR b prev#TCB h    // idletcb.prev = &idletcb
    mrm b h
    ldr &runpt h        // runpt = &idletcb
    mrm b h
    ret
END

DT message "Kernel thread started"

// System idle thread
FUNC TSysThread BEGIN
    ldr &message a
    CALL api::Print
    CALL api::PrintLn
    
    // Let application start user threads
    CALL app::Start
    // Start idle loop
  loop:
    nop
    CALL api::Suspend
    ldr &loop c
    jmp c
END

FUNC Startup BEGIN
    CALL SetupHandlers
    CALL CreateSysThread    
    
    // Return system thread stack pointer    
    ldr &runpt a
    RPTR a sp#TCB b
    mmr b a             // return runpt->sp    
    ret
END

FUNC CreateThread // stack_top, func, param, tcb
BEGIN
    push d
    CALL InitStack             // a <- new_stack
    pop b                      // b <- tcb
    
    PTR b sp#TCB h
    mrm a h                    // tcp.sp = a
      
    ldr &runpt d               // d <- runpt
    mmr d d                    // d <- *runpt
    
    PTR d next#TCB h
    mmr h e                    // e <- runpt->next
    
    mrm b h                    // runpt->next = tcb
    
    PTR b next#TCB h    
    mrm e h                    // tcp.next = e
    
    PTR b prev#TCB h
    mrm d h                    // tcp.prev = *runpt
    
    PTR e prev#TCB h
    mrm b h                    // runpt->next.prev = tcb    
    
    ret
END

// Init stack for a new thread
FUNC InitStack // stack_top, func, param -> new_stack
BEGIN
    mrr a h             // Save stack top as initial FP

    mrm b a             // Thread start = <func>
    ldc 4 d
    add a d a
    
    mrm c a             // Func <param> passed in a
    
    ldc 32 e            // Leave 4*8 bytes for GPRs
    add a e a
        
    mrm h a
    add a d a           // Start thread with fp = sp
    ret
END
    
// Setup interrupt handlers
FUNC SetupHandlers BEGIN
    // Loopback handler
    ldr &HLoopback a
    ldc 0 b     // int 0 handler address
    mrm a b     // Handler = loopback

    // Setup timer
    ldr &HScheduler a
    ldc 4 b     // int 1 handler address
    mrm a b     // Handler = scheduler
    ldc 1 a     // enable == 1
    out a       // Enable timer
    
    ret
END

// User interrupt handler - invokes kernel functions
// HLoopback(service_number, [params])
FUNC HLoopback BEGIN
  suspend: // a == 0
    ldr &serial h
    jgt a h
    ldr &HScheduler h       // NB: no 'cll' instruction
    jmp h                   // - saving the stack intact
    
  serial: // a == 1
    ldc 1 g
    sub a g a
    ldr &create_thread h
    jgt a h
    mrr b a
    CALL HWriteSerial
    irx
    
  create_thread: // a == 2
    mrr e a    
    CALL CreateThread
    irx
END
    
// Writes a char to serial peripheral
// HWriteSerial(symbol)
FUNC HWriteSerial BEGIN
    ldc 64 b                // serial MM base
    mrm a b
    ldc 2 c                 // serial device number
    out c                   // signal serial
    ret
END

// Timer tick handler - schedule the next thread
FUNC HScheduler BEGIN
    ldr &runpt a
    
    // Save stack pointer
    RPTR a sp#TCB b
    ssp c
    mrm c b         // runpt->sp = sp

    RPTR a next#TCB b
    mmr b e         // e = runpt->next

    // Update running TCB
    mrm e a

    // Fetch new stack pointer    
    RPTR a sp#TCB b
    mmr b c
    lsp c

    // Resume that thread
    irx    
END

